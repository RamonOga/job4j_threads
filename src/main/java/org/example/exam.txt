 ==============================================
1. Чем отличается процесс от потока?
==============================================
Процессы и потоки связаны друг с другом, но при этом имеют существенные различия.
Процесс — экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы (например, процессорное время и память).
Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и структурам данных другого.
 Если процесс хочет получить доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие. Это могут быть конвейеры, файлы,
  каналы связи между компьютерами и многое другое.

Поток использует то же самое пространства стека, что и процесс, а множество потоков совместно используют данные своих состояний.
Как правило, каждый поток может работать (читать и писать) с одной и той же областью памяти, в отличие от процессов,
которые не могут просто так получить доступ к памяти другого процесса. У каждого потока есть собственные регистры и собственный стек,
но другие потоки могут их использовать.

Поток — определенный способ выполнения процесса. Когда один поток изменяет ресурс процесса, это изменение сразу же становится видно другим потокам этого процесса.

https://www.youtube.com/watch?v=TkboRk64DbQ&ab_channel=DemidOnline
https://habr.com/ru/post/164487/

==========================================================
2. Каким образом можно создать поток?
==============================================
Способ 1:
Создать объект класса Thread, передав ему в конструкторе нечто, реализующее интерфейс Runnable. Этот интерфейс содержит метод run(),
который будет выполняться в новом потоке. Поток закончит выполнение, когда завершится его метод run().

Способ 2:
Создать потомка класса Thread и переопределить его метод run():
Другие способы:
ThreadPool, ExecutorService, ForkJoinPool

https://habr.com/ru/post/164487/

=============================================================
3. Как работают методы sleep, yield, wait, notify и notifyAll?
===============================================================
Метод Thread.sleep():
Thread.sleep() — статический метод класса Thread, который приостанавливает выполнение потока, в котором он был вызван.
Во время выполнения метода sleep() система перестает выделять потоку процессорное время, распределяя его между другими потоками.
Метод sleep() может выполняться либо заданное кол-во времени (миллисекунды или наносекунды) либо до тех пор пока он не будет остановлен прерыванием
(в этом случае он сгенерирует исключение InterruptedException).

Метод yield():
Статический метод Thread.yield() заставляет процессор переключиться на обработку других потоков системы.
Метод может быть полезным, например, когда поток ожидает наступления какого-либо события и необходимо чтобы
проверка его наступления происходила как можно чаще. В этом случае можно поместить проверку события и метод Thread.yield()
в цикл

Метод wait()
У метода wait() есть три вариации. Один метод wait() бесконечно ждет другой поток, пока не будет вызван метод notify()
или notifyAll() на объекте. Другие две вариации метода wait() ставят текущий поток в ожидание на определенное время.
По истечении этого времени поток просыпается и продолжает работу.

Метод notify()
Вызов метод notify() пробуждает только один поток, после чего этот поток начинает выполнение.
Если объект ожидают несколько потоков, то метод notify() разбудит только один из них.
Выбор потока зависит от системной реализации управления потоками.

Метод notifyAll()
Метод notifyAll() пробуждает все потоки, хотя в какой последовательности они будут пробуждаться зависит от реализации ОС.


=================================================================
4. Объясните следующие термины: монитор, мьютекс, критическая секция.
=================================================================


============================================================
5. Как работает join()?
=============================================================
В Java предусмотрен механизм, позволяющий одному потоку ждать завершения выполнения другого. Для этого используется метод join().
Например, чтобы главный поток подождал завершения побочного потока myThready, необходимо выполнить инструкцию myThready.join() в главном потоке.
 Как только поток myThready завершится, метод join() вернет управление, и главный поток сможет продолжить выполнение.

Метод join() имеет перегруженную версию, которая получает в качестве параметра время ожидания.
 В этом случае join() возвращает управление либо когда завершится ожидаемый поток, либо когда закончится время ожидания.
  Подобно методу Thread.sleep() метод join может ждать в течение миллисекунд и наносекунд – аргументы те же.

==================================================
6. Что такое DeadLock? Приведите примеры.
==================================================
Взаи́мная блокиро́вка (сокращённо взаимоблокировка, англ. deadlock) — ситуация в многозадачной среде или СУБД,
при которой несколько процессов находятся в состоянии ожидания ресурсов, занятых друг другом,
 и ни один из них не может продолжать свое выполнение[1].

два клиента (потока), два ресурса. Первый клиент захватывает первый ресурс, второй клиент - второй ресурс.
После этого первый клиент пытается захватить второй ресурс и попадает в состояние ожидания. Зеркально - второй клиент и первый ресурс.
 Оба ждут: дедлок.

 Для обнаружения существуют механизмы в VirtualVM и в самой джаве:
  ThreadMXBean tMXB = ManagementFactory.getThreadMXBean();
  long[] deadlockedThreads = tMXB.findDeadlockedThreads();
  if (deadlockedThreads != null) {
      ThreadInfo[] threadInfo = tMXB.getThreadInfo(deadlockedThreads);
      for (ThreadInfo info : threadInfo) {
          System.out.println(info);
      }
  }



=============================================================
17. Что такое потоки-демоны?
=============================================================
Завершение процесса и демоны

В Java процесс завершается тогда, когда завершается последний его поток. Даже если метод main() уже завершился, но еще выполняются порожденные им потоки, система будет ждать их завершения.

Однако это правило не относится к особому виду потоков – демонам. Если завершился последний обычный поток процесса, и остались только потоки-демоны, то они будут принудительно завершены и выполнение процесса закончится. Чаще всего потоки-демоны используются для выполнения фоновых задач, обслуживающих процесс в течение его жизни.

Объявить поток демоном достаточно просто — нужно перед запуском потока вызвать его метод setDaemon(true);
Проверить, является ли поток демоном, можно вызвав его метод boolean isDaemon();
https://habr.com/ru/post/164487/





