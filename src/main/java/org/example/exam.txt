
http://www.duct-tape-architect.ru/?p=294#48___CountDownLatch_Barrier

===============================================
1. Чем отличается процесс от потока?
==============================================
Процессы и потоки связаны друг с другом, но при этом имеют существенные различия.
Процесс — экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы (например, процессорное время и память).
Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и структурам данных другого.
 Если процесс хочет получить доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие. Это могут быть конвейеры, файлы,
  каналы связи между компьютерами и многое другое.

Поток использует то же самое пространства стека, что и процесс, а множество потоков совместно используют данные своих состояний.
Как правило, каждый поток может работать (читать и писать) с одной и той же областью памяти, в отличие от процессов,
которые не могут просто так получить доступ к памяти другого процесса. У каждого потока есть собственные регистры и собственный стек,
но другие потоки могут их использовать.

Поток — определенный способ выполнения процесса. Когда один поток изменяет ресурс процесса, это изменение сразу же становится видно другим потокам этого процесса.

https://www.youtube.com/watch?v=TkboRk64DbQ&ab_channel=DemidOnline
https://habr.com/ru/post/164487/

==========================================================
2. Каким образом можно создать поток?
==============================================
Способ 1:
Создать объект класса Thread, передав ему в конструкторе нечто, реализующее интерфейс Runnable. Этот интерфейс содержит метод run(),
который будет выполняться в новом потоке. Поток закончит выполнение, когда завершится его метод run().

Способ 2:
Создать потомка класса Thread и переопределить его метод run():
Другие способы:
ThreadPool, ExecutorService, ForkJoinPool

https://habr.com/ru/post/164487/

=============================================================
3. Как работают методы sleep, yield, wait, notify и notifyAll?
===============================================================
Метод Thread.sleep():
Thread.sleep() — статический метод класса Thread, который приостанавливает выполнение потока, в котором он был вызван.
Во время выполнения метода sleep() система перестает выделять потоку процессорное время, распределяя его между другими потоками.
Метод sleep() может выполняться либо заданное кол-во времени (миллисекунды или наносекунды) либо до тех пор пока он не будет остановлен прерыванием
(в этом случае он сгенерирует исключение InterruptedException).

Метод yield():
Статический метод Thread.yield() заставляет процессор переключиться на обработку других потоков системы.
Метод может быть полезным, например, когда поток ожидает наступления какого-либо события и необходимо чтобы
проверка его наступления происходила как можно чаще. В этом случае можно поместить проверку события и метод Thread.yield()
в цикл

Метод wait()
У метода wait() есть три вариации. Один метод wait() бесконечно ждет другой поток, пока не будет вызван метод notify()
или notifyAll() на объекте. Другие две вариации метода wait() ставят текущий поток в ожидание на определенное время.
По истечении этого времени поток просыпается и продолжает работу.

Метод notify()
Вызов метод notify() пробуждает только один поток, после чего этот поток начинает выполнение.
Если объект ожидают несколько потоков, то метод notify() разбудит только один из них.
Выбор потока зависит от системной реализации управления потоками.

Метод notifyAll()
Метод notifyAll() пробуждает все потоки, хотя в какой последовательности они будут пробуждаться зависит от реализации ОС.


=================================================================
4. Объясните следующие термины: монитор, мьютекс, критическая секция.
=================================================================


============================================================
5. Как работает join()?
=============================================================
В Java предусмотрен механизм, позволяющий одному потоку ждать завершения выполнения другого. Для этого используется метод join().
Например, чтобы главный поток подождал завершения побочного потока myThready, необходимо выполнить инструкцию myThready.join() в главном потоке.
 Как только поток myThready завершится, метод join() вернет управление, и главный поток сможет продолжить выполнение.

Метод join() имеет перегруженную версию, которая получает в качестве параметра время ожидания.
 В этом случае join() возвращает управление либо когда завершится ожидаемый поток, либо когда закончится время ожидания.
  Подобно методу Thread.sleep() метод join может ждать в течение миллисекунд и наносекунд – аргументы те же.

==================================================
6. Что такое DeadLock? Приведите примеры.
==================================================
Взаи́мная блокиро́вка (сокращённо взаимоблокировка, англ. deadlock) — ситуация в многозадачной среде или СУБД,
при которой несколько процессов находятся в состоянии ожидания ресурсов, занятых друг другом,
 и ни один из них не может продолжать свое выполнение[1].

два клиента (потока), два ресурса. Первый клиент захватывает первый ресурс, второй клиент - второй ресурс.
После этого первый клиент пытается захватить второй ресурс и попадает в состояние ожидания. Зеркально - второй клиент и первый ресурс.
 Оба ждут: дедлок.

 Для обнаружения существуют механизмы в VirtualVM и в самой джаве:
  ThreadMXBean tMXB = ManagementFactory.getThreadMXBean();
  long[] deadlockedThreads = tMXB.findDeadlockedThreads();
  if (deadlockedThreads != null) {
      ThreadInfo[] threadInfo = tMXB.getThreadInfo(deadlockedThreads);
      for (ThreadInfo info : threadInfo) {
          System.out.println(info);
      }
  }

==============================================================
7. Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap.
==============================================================
Оба являются синхронизированными версиями HashMap c различиями в функциональности и внутренней структуре.
Как указано выше ConcurrentHashMap состоит из внутренних сегментов, которые могут рассматриваться как независимые HashMap’ы концептуально.
 Все эти сегменты могу быть заблокированы отдельными потоками выполняемыми одновременно.
 Таким образом несколько потоков могу одновременно получить/положить пары key-value из ConcurrentHashMap без блокирования/ожидания друг друга.

Из Collections.synchronizedMap() мы получаем синхронизированную версию HashMap и доступ в блокировании образом.
 Это означает то что если несколько потоков пытаются получить доступ к synchronizedMap в одно и тоже время им будет
  позволено взять/положить пары key-value по одному синхронизированному образу.


=============================================================
8. Различия в интерфейсах Runnable и Callable.
=============================================================
Экземпляр Callable<V> возвращает результат типа V , тогда как экземпляр Runnable - нет.
Экземпляр Callable<V> может генерировать отмеченные исключения, тогда как экземпляр Runnable не может
Разработчики Java почувствовали потребность в расширении возможностей интерфейса Runnable ,
 но они не хотели влиять на использование интерфейса Runnable , и, вероятно, это было причина,
 по которой они пошли на создание отдельного интерфейса с именем Callable в Java 1.5, чем изменение уже существующего Runnable .


=============================================================
9. Различя между isInterrupted(), interrupted().
=============================================================
Thread.interrupted() вдобавок к проверке снимает флаг прерывания.
thread.isInterrupted() этого не делает, плюс нестатический доступ позволяет проверять другие треды.
Фактически, это еще и ограничивает возможность снять флаг прерывания у других тредов
(нельзя "украсть" прерывание другого треда).

Метод interrupted является статическим и проверяет был ли установлен флаг прерывания у текущего потока.
При этом флаг прерывания после вызова этого метода сбрасывается.

Метод isInterrupted() позволяет проверить флаг прерывания у потока, для которого этот метод был вызван.
При этом сам флаг не сбрасывается.

=============================================================
10. Что происходит при вызове Thread.interrupt()?
=============================================================
Thread.interrupt() устанавливает статус прерывания / флаг целевого потока. Затем код, запущенный в этом целевом потоке MAY,
 опрашивает состояние прерывания и обрабатывает его соответствующим образом. Некоторые методы, которые блокируют,
  такие как Object.wait() , могут немедленно использовать состояние прерывания и выдавать соответствующее исключение (обычно InterruptedException )

Прерывание в Java не является упреждающим. Другими словами, оба потока должны сотрудничать, чтобы правильно обработать прерывание.
 Если целевой поток не опрашивает состояние прерывания, то прерывание фактически игнорируется.

Опрос происходит с помощью метода Thread.interrupted() , который возвращает текущее состояние прерывания потока AND
 очищает этот флаг прерывания. Обычно поток может затем сделать что-то вроде throw InterruptedException.

EDIT (из комментариев Тило): Some API методы имеют встроенную обработку прерываний. Из верхней части моей головы это включает в себя.

Object.wait() , Thread.sleep() и Thread.join()
Большинство java.util.concurrent структур
Java NIO (но не java.io) и он не использует InterruptedException , вместо этого используя ClosedByInterruptException .
EDIT (из ответа @thomas-pornin на точно такой же вопрос для полноты картины)

Прерывание нити-это мягкий способ подтолкнуть нить. Он используется для того ,
чтобы дать потокам возможность выйти чисто, в отличие от Thread.stop() , что больше похоже на стрельбу по потоку из штурмовой винтовки.


=============================================================
11. Перечислите ВСЕ причины по которым может выскочить InterruptedException.
=============================================================
Поток ждет в wait, sleep(…), join() или заблокирован на длительное время аналогичным вызовом.. и из соседнего потока дернули interrupt()

Поток прерван во время ожидания на мониторе
Поток прерван во время засыпания
Поток прерван во время захвата ReentrantLock через lockInterruptibly
Поток прерван во время ожидания в CountDownLatch через await
Поток прерван во время ожидания в CyclicBarrier через await
Поток прерван во время ожидания в Condition через await
Поток прерван во время захвата попытки в Semaphore через acquireUninterruptibly
Поток прерван во время получения значения в Future через get
Поток прерван во время обмена значенимя в Exchanger через exchange
Поток прерван во время блокирующих операций с BlockingQueue
Поток прерван во время работы с I/O через InterruptableChannel

В общем, почти любой блокирующий метод выбрасывает это исключение.

=============================================================
12. Назовите отличия synchronize{} и ReentrantLock.
=============================================================
synchronize — более примитивная конструкция которая обязывает нас отпустить monitor по окончании секции.
Таким образом захват\освобождение всегда идут парами и всегда связаны с некоторым блоком кода
ReentrantLock — можно захватывать и освобождать мониторы в произвольном порядке, дает гибкость но сложнее сделать все правильно.
 Также есть опция fair — следить ли за «честным» порядком предоставления доступа\времени ожидания потоков на мониторе.
ReentrantLock — лучше масштабируется при росте числа потоков.

Итак, в общем случае считаем, что synchronized - это просто простой в использовании и сжатый подход к блокировке.
Вы можете добиться точно таких же эффектов синхронизации, написав код с ReentrantLock с еще большим количеством кода
(но он предлагает больше возможностей и гибкости).


Некоторое время назад ReentrantLock был быстрее в определенных условиях (например, с высоким разрешением),
но теперь Java использует различные методы оптимизации (например, блокировку укупорки и адаптивную блокировку),
 чтобы сделать различия во многих типичных сценариях едва заметными программист.

Также была проделана большая работа по оптимизации внутренней блокировки в случаях с низким уровнем конкуренции
 (например, смещенная блокировка). Авторам платформы Java нравится стиль synchronized и встроенный подход, они хотят,
  чтобы программисты не боялись использовать этот удобный инструмент (и предотвращать возможные ошибки). Вот почему оптимизация synchronized и
   "синхронизация медленная" - это очень сложная задача для Sun и Oracle.

=============================================================
13. Приведите наиболее существенное отличие между CountDownLatch и Barrier.
=============================================================



=============================================================
14. Отличие Thread.start() и Thread.run()?
=============================================================
Разница в том, что когда программа вызывает метод start() , создается новый поток и код внутри run() выполняется в новом потоке:
 в то время как если вы вызываете метод run() напрямую, новый поток не создается, и код внутри run()
 будет выполняться непосредственно в текущем потоке.

Еще одно различие между start() и run() в потоке Java заключается в том, что вы не можете вызвать start() дважды.
После запуска второй вызов start() вызовет IllegalStateException в Java, в то время как вы можете вызвать метод run() несколько раз,
 так как это просто обычный метод.


=============================================================
15. Объясните ключевое слово volatile.
=============================================================
Volatile используется, когда вы хотите сделать что-то доступным для модификации в нескольких потоках.
Он помечает переменную как non-locally-cache-able для любого потока. Все операции чтения и записи выполняются из памяти для всех ваших потоков.

Ключевое слово Volatile в Java используется в качестве индикатора для компилятора Java и потока,
которые не кэшируют значение этой переменной и всегда считывают его из основной памяти.


=============================================================
16. Расскажите про приоритеты потока.
=============================================================
Каждому потоку исполнения в Java присваивается свой приоритет, который определяет поведение данного потока по отношению к другим потокам.
 Приоритеты потоков исполнения задаются целыми числами (обычно от 1 до 10), определяющими относительный приоритет одного потока над другими.

Приоритет потока исполнения используется для принятия решения при переходе от одного потока исполнения к другому.
Это так называемое переключение контекста. Задается с помощью метода public final void setPriority(int newPriority).

По умолчанию приоритет потока 5.

Существуют следующие константы для определения приоритета потока:

Thread.MIN_PRIORITY (1)
Thread.NORM_PRIORITY (5)
Thread.MAX_PRIORITY (10)
НЕ полагайтесь на приоритет потоков при проектировании многопоточных приложений!
Скорее всего планировщик потоков будет использовать приоритеты при выборе следующего потока на выполнение,
 но это НЕ гарантируется.




=============================================================
17. Что такое потоки-демоны?
=============================================================
Завершение процесса и демоны

В Java процесс завершается тогда, когда завершается последний его поток. Даже если метод main() уже завершился, но еще выполняются порожденные им потоки, система будет ждать их завершения.

Однако это правило не относится к особому виду потоков – демонам. Если завершился последний обычный поток процесса, и остались только потоки-демоны, то они будут принудительно завершены и выполнение процесса закончится. Чаще всего потоки-демоны используются для выполнения фоновых задач, обслуживающих процесс в течение его жизни.

Объявить поток демоном достаточно просто — нужно перед запуском потока вызвать его метод setDaemon(true);
Проверить, является ли поток демоном, можно вызвав его метод boolean isDaemon();
https://habr.com/ru/post/164487/

=============================================================
18. Назовите все возможные состояния потока.
=============================================================

RUNNABLE- работает
TERMINATED- уничтожен
WAITING- ожидает.
BLOCKED- заблокирован и ждет разблокировки.
NEW- создан, но не запущеню
TIME_WAITING - ожидает по времени

1. New:
Когда создается новый поток, он находится в состоянии New, причем запускаться поток еще не начал.
 Не начал запускаться его код, ему еще предстоит выполниться.
Пример: новый поток создается, но не запускается, поэтому остается вот таким:

Объект Thread пуст, и ресурсы для потока недоступны. Если пользователь вызовет какой-то другой метод, кроме start(),
 произойдет ошибка IllegalThreadStateExecption.

2. Runnable:
Поток, готовый к запуску, переходит в состояние runnable.
В этом состоянии поток либо запускается, либо готов в любой момент запуститься.
 Дальше свою работу выполняет планировщик потоков, предоставляющий время для выполнения потока.
  В большинстве операционных систем он каждому потоку выделяет небольшое количество процессорного времени.
  Когда это происходит, все такие потоки, которые готовы к запуску, ждут центральный процессор,
  а выполняемый в этот момент времени поток находится в состоянии runnable.

3. Blocked:
При попытке выполнить задачу, которая не может быть завершена в данный момент времени,
поток из состояния runnable переходит в состояние blocked. И ждет, пока задача не будет завершена.
Например, когда поток ожидает завершения операций ввода-вывода, он находится в состоянии blocked.
Поток в этом состоянии не может дальше продолжать выполнение до тех пор, пока не перейдет в состояние runnable.
 Планировщик потоков повторно активирует blocked/waiting (блокированный/ожидающий) поток и планирует его выполнение.
  Любой поток, находясь в одном из этих состояний, не потребляет процессорное время.

4. Waiting:
Ожидающий поток (FastThread)
Когда поток находится в состоянии waiting, он ждет другой поток, связанный условием.
 Когда это условие выполняется, планировщик получает уведомление и вызываются методы notify ()
 или notifyAll(). В этом случае ожидающий поток переходит в состояние runnable.
Если выполняемый в это время поток переходит в состояние blocked/waiting, планировщик
дает добро на выполнение ожидающего потока, перешедшего в состояние runnable. Именно планировщик потоков определяет,
какой поток должен выполняться.

5. Time waiting:
Поток находится в состоянии runnable. Теперь он вызывает метод sleep(t),
 wait(t) или join(t) с неким промежутком времени в качестве параметра и переходит в состояние
 time waiting. Поток остается в этом состоянии до тех пор, пока время ожидания не выйдет или пока
  не будет получено уведомление. Например, когда поток вызывает sleep или условное ожидание, он переходит в состояние
  timed waiting (ожидание с ограничением по времени). Как только время выйдет, поток вернется в состояние runnable.

6. Terminate:
Поток завершается по любой из следующих причин:
· Поток завершается в обычном режиме, когда код потока полностью выполнен программой.
· При выполнении потока произошло какое-то нештатное событие, сопровождаемое появлением ошибки,
например ошибки сегментации или необработанного исключения.


=============================================================
19. Что такое race condition?
=============================================================

Состояние гонки возникает, когда два или более потоков могут получить доступ к общим данным,
 и они пытаются изменить их одновременно. Поскольку алгоритм планирования потоков может переключаться
 между потоками в любое время, вы не знаете порядок, в котором потоки будут пытаться получить доступ к общим данным.
 Следовательно, результат изменения данных зависит от алгоритма планирования потоков, то есть оба потока «участвуют в гонке»,
  чтобы получить доступ / изменить данные.

Проблемы часто возникают, когда один поток выполняет «check-then-act» (например, «check», если значение равно X,
 затем «act», чтобы сделать что-то, зависящее от значения, являющегося X), а другой поток делает что-то со значением
 в между «чеком» и «актом».

 Дело в том, что у может быть 10 или может быть любым, в зависимости от того, изменился ли другой поток х между проверкой и действием.
  У вас нет реального способа узнать.

 Чтобы предотвратить возникновение условий гонки, вы обычно устанавливаете блокировку вокруг общих данных,
 чтобы обеспечить доступ к данным одновременно только одному потоку. Это будет означать что-то вроде этого:

=============================================================
20. Что такое Thread Local переменная?
=============================================================
Класс ThreadLocal представляет хранилище тред-локальных переменных. По способу использования он похож на обычную обертку над значением,
с методами get(), set() и remove() для доступа к нему, и дополнительным фабричным методом ThreadLocal.withInitial(), устанавливающим значение по-умолчанию.

Отличие тред-локальной переменной от обычной в том, что ThreadLocal хранит отдельную независимую копию значения для каждого ее использующего потока.
 Работа с такой переменной потокобезопасна.

Проще говоря, объект класса ThreadLocal хранит внутри не одно значение, а как бы хэш-таблицу поток➝значение,
и при использовании обращается к значению для текущего потока.

Первый, самый очевидный вариант использования – данные, относящиеся непосредственно к треду, определенный пользователем «контекст потока».
 На скриншоте ниже пример такого использования: ThreadId.get() вернет порядковый номер текущего треда.

Другой случай, с которым локальная переменная потока может помочь – кэширование read-only данных в многопоточной среде без дорогостоящей синхронизации.

Помимо обычного ThreadLocal, в стандартной библиотеке присутствует его расширение InheritableThreadLocal.
Этот класс «наследует» значение – изначально берет его для потока, являющегося родителем текущего.


=============================================================
21. Что такое FutureTask?
=============================================================

=============================================================
22. Что такое Thread Pool?
=============================================================
https://habr.com/ru/post/554608/
Мы создавали ThreadPool на курсе. в нем содержаться Queue Runnable обьектов и Set потоков.

 ExecutorService es = Executors.newFixedThreadPool()

В пуле потоков создается группа потоков фиксированного размера. Всякий раз, когда задача должна быть предоставлена,
один из потоков извлекается и назначается этой задачей поставщиком услуг, как только задание завершается, поток возвращается
обратно в пул потоков. Пул потоков предпочтительно используется, потому что активные потоки потребляют системные ресурсы,
когда JVM создает слишком много потоков одновременно, системе может не хватить памяти.

=============================================================
23. Что такое Semaphore?
=============================================================
https://pro-java.ru/parallelizm-v-java/klass-semaphore-primery-realizacii-koda-v-java/
Семафор управляет доступом к обще­му ресурсу с помощью счетчика. Если счетчик больше нуля, доступ разрешается,
а если он равен нулю, то в доступе будет отказано.

В действительности этот счетчик подсчитывает разрешения, открывающие доступ к общему ресурсу.
Следовательно,чтобы получить доступ к ресурсу, поток исполнения должен получить у семафора разрешение на доступ.

Как правило, поток исполнения, которому требуется доступ к общему ресурсу, и пытается получить разрешение,
чтобы воспользоваться семафором. Если значе­ние счетчика семафора окажется больше нуля, поток исполнения получит разре­шение,
после чего значение счетчика семафора уменьшается на единицу. В про­тивном случае поток будет заблокирован до тех пор,
пока он не сумеет получить разрешение.

Если потоку исполнения доступ к общему ресурсу больше не нужен,он освобождает разрешение, в результате чего значение
счетчика семафора увеличивается на единицу. Если в это время другой поток исполнения ожидает разрешения, то он сразу же его получает.
В Java этот механизм реализуется в классе Semaphore.

Чтобы получить разрешение, достаточно вызвать метод acquire()

Чтобы освободить разрешение, следует вызвать метод release()

=============================================================
24. Чем отличается submit от execute у ExecutorServices?
=============================================================

Разница в том, что execute просто запускает задачу без каких-либо дополнительных атак, тогда как submit
возвращает объект Future для управления задачей. Вы можете сделать следующее с объектом Future:

Отменить задачу преждевременно, используя метод cancel.
Дождитесь завершения выполнения задачи с помощью get.
Интерфейс Future более полезен, если отправить пул Callable в пул. Возвращаемое значение метода call будет
возвращено при вызове Future.get. Если вы не поддерживаете ссылку на Future, нет никакой разницы.
=============================================================
25. Чем отличается shutdown от shutdownNow у ThreadPoolExecutor?
=============================================================
shutdown():
для завершения потоков внутри ExecutorService вы вызываете его shutdown() метод. ExecutorService не завершит работу немедленно,
 но он больше не будет принимать новые задачи, и как только все потоки закончили текущие задачи, ExecutorService завершает работу.
  Все задачи, переданные в Службу ExecutorService перед вызовом shutdown (), выполняются.

shutdownNow():
если вы хотите выключить ExecutorService немедленно, вы можете вызвать shutdownNow() метод. Это будет пытаться остановить
все выполняемые задачи сразу, и пропускает все отправленные, но не обработанные задачи. Нет никаких гарантий относительно выполнения задач.
 Возможно, они остановятся, возможно, казнят до конца. Это лучшая попытка усилия.

=============================================================
27. Как создать ThreadPool у ExecutorService только на 1, на 5, на неограниченное количество потоков.
=============================================================

=============================================================
28. Что такое ReadWriteLock?
=============================================================

=============================================================
29. В чём отличие Thread от FutureTask? В чём отличие Thread.interrupt() и FutureTask.cancel().
=============================================================

=============================================================
30. Расскажите про шаблон проектирования Producer Consumer.
=============================================================




